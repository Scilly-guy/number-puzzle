<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Puzzle</title>
    <style>
        body{
            background-color: black;
        }
    </style>
</head>
<body>
    <Button id="regen">Regen</Button>
    <svg id="game_area" viewBox="0 0 1000 2500">
    <style>
        .highlight:hover{
            stroke:black;
            stroke-width: 2px;
        }
    </style></svg>
    <script>
        console.log("Script started")
        const gameArea=document.getElementById("game_area");
        const regen_button=document.getElementById("regen")
        const svg_namespace="http://www.w3.org/2000/svg"
        const box_size=50
        const padding=3
        const colours=["#4287f5","#805E73","#FFC6D9","#DD6E42","#21FA90","#EBF5EE","#E5D352","teal"]
        let ctrlHeld = false;

        window.addEventListener("keydown", (e) => {
        if (e.ctrlKey || e.metaKey) {
            ctrlHeld = true;
        }
        });

        window.addEventListener("keyup", (e) => {
        // Update state properly when either key is released
        if (!e.ctrlKey && !e.metaKey) {
            ctrlHeld = false;
        }
        });

        drawBeforeAfter(7)

        regen_button.addEventListener("click",()=>{
            while(gameArea.firstChild){
                gameArea.firstChild.remove()
            }
            drawBeforeAfter(8)
        })

        function drawBeforeAfter(size){
            const data=rasterVoronoi(size,size,7)
            //drawGrid(size,data,0)
            minRegionSize(data,6)
            const game=generateSolution(data)
            game.grid=fillGridRandom(game,data)
            drawGrid(size,data,game,0)
        }

        function drawGrid(size,regioned_grid,game,offset_y){
            console.log("drawing a grid")
            const first_cells=[]
            game.regions.forEach(region=>{first_cells.push(region[0])})
            for(var i=0;i<size;i++){
                for(var j=0;j<size;j++){
                    let first_cell_index=-1
                    first_cells.forEach((cell,index)=>{
                        if(cell.x===j && cell.y===i){
                            first_cell_index=index
                        }
                    })
                    let total=0
                    if(first_cell_index>=0){
                        total=game.totals[first_cell_index]
                    }
                    drawBox(i,j,regioned_grid[i][j],game.grid[i][j],offset_y,total)
                }
            }
        }

        function drawBox(grid_x,grid_y,region_colour,number,offset_y,total){
            const box=createSvgElement("rect",{
                width:box_size,
                height:box_size,
                x:grid_x*box_size+grid_x*padding,
                y:grid_y*box_size+grid_y*padding+offset_y,
                fill:colours[region_colour],
                stroke:"#aaaaaa",
                "stroke-width":"1"
            })
            box.classList.add("highlight")
            let number_x=grid_x*box_size+box_size/2+grid_x*padding;
            let number_y=grid_y*box_size+box_size/2+grid_y*padding+offset_y;

            const circle=createSvgElement("circle",{
                r:box_size/4,
                cx:grid_x*box_size+grid_x*padding+box_size/2,
                cy:grid_y*box_size+grid_y*padding+box_size/2+offset_y,
                fill:"none",
                stroke:"none",
                "stroke-width":"1"
            })

            const number_element=createSvgElement("text",{
                x:number_x,
                y:number_y,
            })
            number_element.textContent=number

            const total_element=createSvgElement("text",{
                x:number_x-box_size/2+3,
                y:number_y-box_size/2+12,
                "font-size":10
            })
            if(total>0){
                total_element.textContent=total
            }
            const group=createSvgElement("g",{})
            group.append(box,number_element,total_element,circle)
            group.addEventListener('click',()=>{
                if(ctrlHeld){
                    console.log(`Remove (${grid_x},${grid_y})`)
                    number_element.textContent=""
                }
                else{
                    console.log(`Confirm (${grid_x},${grid_y})`)
                    circle.setAttributeNS(null,"stroke","#aaaaaa")
                }
            })
            gameArea.append(group)
            const bbox=number_element.getBBox()
            number_element.setAttributeNS(null,"x",number_x-bbox.width/2)
            number_element.setAttributeNS(null,"y",number_y+bbox.height/2)
        }

        function createSvgElement(element_name,options){
            const element=document.createElementNS(svg_namespace,element_name)
            Object.keys(options).forEach(attr=>{
                element.setAttributeNS(null,attr,options[attr])
            })
            return element
        }

        function rasterVoronoi(grid_width,grid_height,number_regions){
            console.log("creating voronoi regions:")
            const x_centers=[]
            const y_centers=[]
            const ids=[]
            const voronoi=[]
            console.log("  creating voronoi centres:")
            for(var i=0;i<number_regions;i++){
                x_centers.push(Math.floor(Math.random()*grid_width))
                y_centers.push(Math.floor(Math.random()*grid_height))
                let id=y_centers[i]*grid_width+x_centers[i]
                while(ids.length>0 && ids.indexOf(id)>=0){
                    console.log(`    indexOf: ${ids.indexOf(id)}`)
                    x_centers[i]=Math.floor(Math.random()*grid_width)
                    y_centers[i]=Math.floor(Math.random()*grid_height)
                    console.log(`    new center:(${x_centers[i]},${y_centers[i]})`)
                    id=y_centers[i]*grid_width+x_centers[i]
                }
                ids.push(id)
            }
            console.log("  calculating regions")
            for(var i=0;i<grid_height;i++){
                const rows=[]
                for(var j=0;j<grid_width;j++){
                    let min_distance=grid_height+grid_width//larger than possible
                    let min_region
                    for(var loop_regions=0;loop_regions<number_regions;loop_regions++){
                        this_distance=distance(i,j,x_centers[loop_regions],y_centers[loop_regions])
                        if(this_distance<min_distance){
                            min_region=loop_regions
                            min_distance=this_distance
                        }
                    }
                    rows.push(min_region)
                }
                voronoi.push(rows)
            }
            return voronoi;
        }

        function minRegionSize(voronoi,min_region_size){
            console.log("performing min size checks:")
            const sizes=[]
            let num_undersized=0
            let changes_made=true
            let count=0
            console.log("  calculating sizes:")
            for(var i=0;i<voronoi.length;i++){
                for(var j=0;j<voronoi[i].length;j++){
                    while(voronoi[i][j]>=sizes.length){
                        sizes.push(0)
                    }
                    sizes[voronoi[i][j]]++
                }
            }
            console.log("  "+sizes)
            sizes.forEach(region=>{if(region<min_region_size)num_undersized++})
            let temp_min_size=min_region_size
            while(num_undersized>0 && count<200){
                console.log(`  Undersized regions: ${num_undersized}`)
                if(changes_made){
                    changes_made=false
                    for(var region=0;region<sizes.length;region++){
                        const cells=getCellsForRegion(region,voronoi)
                        if(sizes[region]>temp_min_size){
                            console.log(`region:${region} size:${sizes[region]}`)
                            //get x range
                            const range={min:voronoi[0].length,max:0}
                            cells.forEach(cell=>{
                                if(cell.x>range.max)range.max=cell.x
                                if(cell.x<range.min)range.min=cell.x
                            })
                            
                            const options=[]
                            for(var option=range.min;option<=range.max;option++){
                                options.push(option)
                            }
                            let foundOne=false
                            while(!foundOne && options.length>0){
                                option_index=Math.floor(Math.random()*options.length)
                                const x=options[option_index]
                                options.splice(option_index,1)
                                let y=0
                                while(y<voronoi.length-1 && voronoi[y][x]!=region){
                                    y++
                                }
                                const above=y-1
                                if(above>=0 && sizes[voronoi[above][x]]<temp_min_size){
                                    sizes[region]--
                                    voronoi[y][x]=voronoi[above][x]
                                    sizes[voronoi[above][x]]++
                                    foundOne=true
                                    changes_made=true
                                    console.log(`  Switched (${x},${above})`)
                                    if(temp_min_size>min_region_size){
                                        temp_min_size--
                                        console.log(`  Decreasing min_size to ${temp_min_size}`)
                                    }
                                    else{
                                        if(sizes[voronoi[above][x]]>=min_region_size)num_undersized--
                                    }
                                }
                                else{
                                    while(y<voronoi.length && voronoi[y][x]==region){
                                        y++
                                    }
                                    const below=y
                                    y--
                                    if(below<voronoi.length && sizes[voronoi[below][x]]<temp_min_size){
                                        sizes[region]--
                                        voronoi[y][x]=voronoi[below][x]
                                        sizes[voronoi[below][x]]++
                                        foundOne=true
                                        changes_made=true
                                        console.log(`  Switched (${x},${below})`)
                                        if(temp_min_size>min_region_size){
                                            temp_min_size--
                                            console.log(`  Decreasing min_size to ${temp_min_size}`)
                                        }
                                        else{
                                            if(sizes[voronoi[below][x]]>=min_region_size)num_undersized--
                                        }
                                    }
                                }
                            }
                            if(!foundOne){
                                //get y range
                                const range={min:voronoi.length,max:0}
                                cells.forEach(cell=>{
                                    if(cell.y>range.max)range.max=cell.y
                                    if(cell.y<range.min)range.min=cell.y
                                })
                                
                                const options=[]
                                for(var option=range.min;option<=range.max;option++){
                                    options.push(option)
                                }
                                let foundOne=false
                                while(!foundOne && options.length>0){
                                    option_index=Math.floor(Math.random()*options.length)
                                    const y=options[option_index]
                                    options.splice(option_index,1)
                                    let x=0
                                    while(voronoi[y][x]!=region){
                                        x++
                                    }
                                    const left=x-1
                                    if(left>=0 && sizes[voronoi[y][left]]<temp_min_size){
                                        sizes[region]--
                                        voronoi[y][x]=voronoi[y][left]
                                        sizes[voronoi[y][left]]++
                                        foundOne=true
                                        changes_made=true
                                        console.log(`  Switched (${left},${y})`)
                                        if(temp_min_size>min_region_size){
                                            temp_min_size--
                                            console.log(`  Decreasing min_size to ${temp_min_size}`)
                                        }
                                        else{
                                            if(sizes[voronoi[y][left]]>=min_region_size)num_undersized--
                                        }
                                    }
                                    else{
                                        while(x<voronoi[y].length && voronoi[y][x]==region){
                                            x++
                                        }
                                        const right=x
                                        x--
                                        if(right<voronoi[y].length && sizes[voronoi[y][right]]<temp_min_size){
                                            sizes[region]--
                                            voronoi[y][x]=voronoi[right][x]
                                            sizes[voronoi[y][right]]++
                                            foundOne=true
                                            changes_made=true
                                            console.log(`  Switched (${right},${y})`)
                                            if(temp_min_size>min_region_size){
                                                temp_min_size--
                                                console.log(`  Decreasing min_size to ${temp_min_size}`)
                                            }
                                            else{
                                                if(sizes[voronoi[y][right]]>=min_region_size)num_undersized--
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(!num_undersized) break;
                    }
                }
                else{
                    temp_min_size++
                    count++
                    changes_made=true
                    console.log(`Increasing min_size to ${temp_min_size}`)
                }
            }
        }

        function generateSolution(regioned_grid){
            const solution=[]
            const regions=[]
            const totals=[]
            for(let i=0;i<regioned_grid.length;i++){
                solution[i]=[]
                for(let j=0;j<regioned_grid[0].length;j++){
                    const chance=Math.floor(Math.random()*100)
                    if(chance<40){
                        solution[i][j]=Math.ceil(Math.random()*9)
                    }
                    else{
                        solution[i][j]=0
                    }
                    while(regioned_grid[i][j]>=regions.length){
                        regions.push([])
                    }
                    regions[regioned_grid[i][j]].push({x:j,y:i})
                }
            }
            regions.forEach((region,index)=>{
                totals.push(0)
                region.forEach(cell=>{
                    totals[index]+=solution[cell.y][cell.x]
                })
                if(totals[index]===0){
                    const random_index=Math.floor(region.length*Math.random())
                    const {x,y}=region[random_index]
                    solution[y][x]=Math.ceil(Math.random()*9)
                    totals[index]=solution[y][x]
                }
            })
            return {solution,totals,regions}
        }

        function fillGridRandom(game,regioned_grid){
            const grid=[]
            game.solution.forEach((row,i)=>{
                grid.push([])
                row.forEach((cell,j)=>{
                    let value=cell
                    if(value===0){
                        value=Math.ceil(Math.random()*9)
                    }
                    grid[i][j]=value
                })
            })
            return grid
        }

        function getCellsForRegion(region,voronoi){
            const cells=[]
            for(var i=0;i<voronoi.length;i++){
                for(var j=0;j<voronoi[i].length;j++){
                    if(voronoi[i][j]===region){
                        cells.push({x:j,y:i})
                    }
                }
            }
            return cells
        }

        function distance(x,y,tx,ty){
            return Math.sqrt(Math.pow(Math.abs(tx-x),2)+Math.pow(Math.abs(ty-y),2))
        }
    </script>
</body>
</html>